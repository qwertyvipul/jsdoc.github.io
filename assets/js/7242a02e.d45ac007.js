"use strict";(self.webpackChunkjsdoc_github_io=self.webpackChunkjsdoc_github_io||[]).push([[8048],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[u]="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={title:"About JSDoc plugins",description:"How to create and use JSDoc plugins."},l=void 0,r={unversionedId:"about-plugins",id:"about-plugins",title:"About JSDoc plugins",description:"How to create and use JSDoc plugins.",source:"@site/docs/about-plugins.md",sourceDirName:".",slug:"/about-plugins",permalink:"/jsdoc.github.io/about-plugins",draft:!1,tags:[],version:"current",frontMatter:{title:"About JSDoc plugins",description:"How to create and use JSDoc plugins."},sidebar:"docsSidebar",previous:{title:"Block and inline tags",permalink:"/jsdoc.github.io/about-block-inline-tags"},next:{title:"Using the Markdown plugin",permalink:"/jsdoc.github.io/plugins-markdown"}},s={},p=[{value:"Creating and Enabling a Plugin",id:"creating-and-enabling-a-plugin",level:2},{value:"Authoring JSDoc 3 Plugins",id:"authoring-jsdoc-3-plugins",level:2},{value:"Event Handlers",id:"event-handlers",level:3},{value:"Event: parseBegin",id:"event-parsebegin",level:4},{value:"Event: fileBegin",id:"event-filebegin",level:4},{value:"Event: beforeParse",id:"event-beforeparse",level:4},{value:"Event: jsdocCommentFound",id:"event-jsdoccommentfound",level:4},{value:"Event: symbolFound",id:"event-symbolfound",level:4},{value:"Event: newDoclet",id:"event-newdoclet",level:4},{value:"Event: fileComplete",id:"event-filecomplete",level:4},{value:"Event: parseComplete",id:"event-parsecomplete",level:4},{value:"Event: processingComplete",id:"event-processingcomplete",level:4},{value:"Tag Definitions",id:"tag-definitions",level:3},{value:"The Dictionary",id:"the-dictionary",level:4},{value:"Node Visitors",id:"node-visitors",level:3},{value:"Making things happen",id:"making-things-happen",level:4},{value:"Reporting Errors",id:"reporting-errors",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"creating-and-enabling-a-plugin"},"Creating and Enabling a Plugin"),(0,i.kt)("p",null,"There are two steps required to create and enable a new JSDoc plugin:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create a JavaScript module to contain your plugin code."),(0,i.kt)("li",{parentName:"ol"},"Include that module in the ",(0,i.kt)("inlineCode",{parentName:"li"},"plugins")," array of ",(0,i.kt)("a",{parentName:"li",href:"about-configuring-jsdoc"},"JSDoc's configuration file"),". You can\nspecify an absolute or relative path. If you use a relative path, JSDoc searches for the plugin in\nthe current working directory; the directory where the configuration file is located; and the JSDoc\ndirectory, in that order.")),(0,i.kt)("p",null,"For example, if your plugin is defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins/shout.js")," file in the current working\ndirectory, you would add the string ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins/shout")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins")," array in your JSDoc\nconfiguration file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Adding a plugin to JSDoc's configuration file"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "plugins": ["plugins/shout"]\n}\n')),(0,i.kt)("p",null,"JSDoc executes plugins in the order that they are listed in the configuration file."),(0,i.kt)("h2",{id:"authoring-jsdoc-3-plugins"},"Authoring JSDoc 3 Plugins"),(0,i.kt)("p",null,"JSDoc 3's plugin system offers extensive control over the parsing process. A plugin can affect the\nparse results by doing any of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Defining event handlers"),(0,i.kt)("li",{parentName:"ul"},"Defining tags"),(0,i.kt)("li",{parentName:"ul"},"Defining a visitor for abstract syntax tree nodes")),(0,i.kt)("h3",{id:"event-handlers"},"Event Handlers"),(0,i.kt)("p",null,"At the highest level, a plugin may register handlers for specific named events that JSDoc fires.\nJSDoc will pass an event object to the handler. Your plugin module should export a ",(0,i.kt)("inlineCode",{parentName:"p"},"handlers")," object\nthat contains your handler, like so:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Event-handler plugin for 'newDoclet' events"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"exports.handlers = {\n    newDoclet: function(e) {\n        // Do something when we see a new doclet\n    }\n};\n")),(0,i.kt)("p",null,"JSDoc fires events in the same order as the underlying code."),(0,i.kt)("p",null,"An event-handler plugin can stop later plugins from running by setting a ",(0,i.kt)("inlineCode",{parentName:"p"},"stopPropagation")," property\non the event object (",(0,i.kt)("inlineCode",{parentName:"p"},"e.stopPropagation = true"),"). A plugin can stop the event from firing by setting\na ",(0,i.kt)("inlineCode",{parentName:"p"},"preventDefault")," property (",(0,i.kt)("inlineCode",{parentName:"p"},"e.preventDefault = true"),")."),(0,i.kt)("h4",{id:"event-parsebegin"},"Event: parseBegin"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"parseBegin")," event is fired before JSDoc starts loading and parsing the source files. Your\nplugin can control which files JSDoc will parse by modifying the event's contents."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": This event is fired in JSDoc 3.2 and later."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sourcefiles"),": An array of paths to source files that will be parsed.")),(0,i.kt)("h4",{id:"event-filebegin"},"Event: fileBegin"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fileBegin")," event is fired when the parser is about to parse a file. Your plugin can use this\nevent to trigger per-file initialization if necessary."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filename"),": The name of the file.")),(0,i.kt)("h4",{id:"event-beforeparse"},"Event: beforeParse"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeParse")," event is fired before parsing has begun. Plugins can use this method to modify the\nsource code that will be parsed. For instance, your plugin could add a JSDoc comment, or it could\nremove preprocessing tags that are not valid JavaScript."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filename"),": The name of the file."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source"),": The contents of the file.")),(0,i.kt)("p",null,"Below is an example that adds a virtual comment for a function to the source so that it will get\nparsed and added to the documentation. This might be done to document methods that will be available\nto users, but might not appear in the source code being documented, such as methods provided by an\nexternal superclass:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"exports.handlers = {\n    beforeParse: function(e) {\n        var extraDoc = [\n            '/**',\n            ' * Function provided by a superclass.',\n            ' * @name superFunc',\n            ' * @memberof ui.mywidget',\n            ' * @function',\n            ' */'\n        ];\n        e.source += extraDoc.join('\\n');\n    }\n};\n")),(0,i.kt)("h4",{id:"event-jsdoccommentfound"},"Event: jsdocCommentFound"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"jsdocCommentFound")," event is fired whenever a JSDoc comment is found. The comment may or may not\nbe associated with any code. You might use this event to modify the contents of a comment before it\nis processed."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filename"),": The name of the file."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment"),": The text of the JSDoc comment."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lineno"),": The line number on which the comment was found."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"columnno"),": The column number on which the comment was found. Available in JSDoc 3.5.0 and later.")),(0,i.kt)("h4",{id:"event-symbolfound"},"Event: symbolFound"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"symbolFound")," event is fired when the parser comes across a symbol in the code that may need to\nbe documented. For example, the parser fires a ",(0,i.kt)("inlineCode",{parentName:"p"},"symbolFound")," event for each variable, function, and\nobject literal in a source file."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filename"),": The name of the file."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment"),": The text of the comment associated with the symbol, if any."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"id"),": The unique ID of the symbol."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lineno"),": The line number on which the symbol was found."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"columnno"),": The column number on which the symbol was found. Available in JSDoc 3.5.0 and later."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"range"),": An array containing the numeric index of the first and last characters in the source file\nthat are associated with the symbol."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"astnode"),": The symbol's node from the abstract syntax tree."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"code"),": Object with detailed information about the code. This object usually contains ",(0,i.kt)("inlineCode",{parentName:"li"},"name"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"type"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"node")," properties. The object might also have ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"paramnames"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"funcscope"),"\nproperties depending on the symbol.")),(0,i.kt)("h4",{id:"event-newdoclet"},"Event: newDoclet"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"newDoclet")," event is the highest-level event. It is fired when a new doclet has been created.\nThis means that a JSDoc comment or a symbol has been processed, and the actual doclet that will be\npassed to the template has been created."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"doclet"),": The new doclet that was created.")),(0,i.kt)("p",null,"The doclet's properties can vary depending on the comment or symbol that the doclet represents. Some\ncommon properties you're likely to see include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment"),": The text of the JSDoc comment, or an empty string if the symbol is undocumented."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"meta"),": Object that describes how the doclet relates to the source file (for example, the location\nwithin the source file)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description"),": A description of the symbol being documented."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"kind"),": The kind of symbol being documented (for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"class")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"function"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": The short name for the symbol (for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"myMethod"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"longname"),": The fully qualified name, including memberof info (for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass#myMethod"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"memberof"),": The module, namespace, or class that this symbol belongs to (for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass"),"),\nor an empty string if the symbol does not have a parent."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"scope"),": The scope of the symbol within its parent (for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"global"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"static"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"instance"),",\nor ",(0,i.kt)("inlineCode",{parentName:"li"},"inner"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"undocumented"),": Set to ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if the symbol did not have a JSDoc comment."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"defaultvalue"),": The default value for a symbol."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type"),": Object containing details about the symbol's type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"params"),": Object containing the list of parameters to a function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tags"),": Object containing a list of tags that JSDoc did not recognize. Only available if\n",(0,i.kt)("inlineCode",{parentName:"li"},"allowUnknownTags")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," in JSDoc's configuration file.")),(0,i.kt)("p",null,"To see the doclets that JSDoc generates for your code, run JSDoc with the ",(0,i.kt)("a",{parentName:"p",href:"about-commandline"},(0,i.kt)("inlineCode",{parentName:"a"},"-X")," command-line\noption"),"."),(0,i.kt)("p",null,"Below is an example of a ",(0,i.kt)("inlineCode",{parentName:"p"},"newDoclet")," handler that shouts the descriptions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"exports.handlers = {\n    newDoclet: function(e) {\n        // e.doclet will refer to the newly created doclet\n        // you can read and modify properties of that doclet if you wish\n        if (typeof e.doclet.description === 'string') {\n            e.doclet.description = e.doclet.description.toUpperCase();\n        }\n    }\n};\n")),(0,i.kt)("h4",{id:"event-filecomplete"},"Event: fileComplete"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fileComplete")," event is fired when the parser has finished parsing a file. Your plugin could use\nthis event to trigger per-file cleanup."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filename"),": The name of the file."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source"),": The contents of the file.")),(0,i.kt)("h4",{id:"event-parsecomplete"},"Event: parseComplete"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"parseComplete")," event is fired after JSDoc has parsed all of the specified source files."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": This event is fired in JSDoc 3.2 and later."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sourcefiles"),": An array of paths to source files that were parsed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"doclets"),": An array of doclet objects. See the ",(0,i.kt)("a",{parentName:"li",href:"#event-newdoclet"},(0,i.kt)("inlineCode",{parentName:"a"},"newDoclet")," event")," for details\nabout the properties that each doclet can contain. Available in JSDoc 3.2.1 and later.")),(0,i.kt)("h4",{id:"event-processingcomplete"},"Event: processingComplete"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"processingComplete")," event is fired after JSDoc updates the parse results to reflect inherited\nand borrowed symbols."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": This event is fired in JSDoc 3.2.1 and later."),(0,i.kt)("p",null,"The event object contains the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"doclets"),": An array of doclet objects. See the ",(0,i.kt)("a",{parentName:"li",href:"#event-newdoclet"},(0,i.kt)("inlineCode",{parentName:"a"},"newDoclet")," event")," for details\nabout the properties that each doclet can contain.")),(0,i.kt)("h3",{id:"tag-definitions"},"Tag Definitions"),(0,i.kt)("p",null,"Adding tags to the tag dictionary is a mid-level way to affect documentation generation. Before a\n",(0,i.kt)("inlineCode",{parentName:"p"},"newDoclet")," event is triggered, JSDoc comment blocks are parsed to determine the description and any\nJSDoc tags that may be present. When a tag is found, if it has been defined in the tag dictionary,\nit is given a chance to modify the doclet."),(0,i.kt)("p",null,"Plugins can define tags by exporting a ",(0,i.kt)("inlineCode",{parentName:"p"},"defineTags")," function. That function will be passed a\ndictionary that can be used to define tags, like so:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"exports.defineTags = function(dictionary) {\n    // define tags here\n};\n")),(0,i.kt)("h4",{id:"the-dictionary"},"The Dictionary"),(0,i.kt)("p",null,"The dictionary provides the following methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"defineTag(title, opts)"),": Used to define tags. The first parameter is the name of the tag (for\nexample, ",(0,i.kt)("inlineCode",{parentName:"li"},"param")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"overview"),"). The second is an object containing options for the tag. You can\ninclude any of the following options; the default value for each option is ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),":",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"+ `canHaveType (boolean)`: Set to `true` if the tag text can include a type expression (such as\n`{string}` in `@param {string} name - Description`).\n+ `canHaveName (boolean)`: Set to `true` if the tag text can include a name (such as `name` in\n`@param {string} name - Description`).\n+ `isNamespace (boolean)`: Set to `true` if the tag should be applied to the doclet's longname\nas a namespace. For example, the `@module` tag sets this option to `true`, and using the tag\n`@module myModuleName` results in the longname `module:myModuleName`.\n+ `mustHaveValue (boolean)`: Set to `true` if the tag must have a value (such as `TheName` in\n`@name TheName`).\n+ `mustNotHaveDescription (boolean)`: Set to `true` if the tag may have a value but must not\nhave a description (such as `TheDescription` in `@tag {typeExpr} TheDescription`).\n+ `mustNotHaveValue (boolean)`: Set to `true` if the tag must not have a value.\n+ `onTagged (function)`: A callback function executed when the tag is found. The function is\npassed two parameters: the doclet and the tag object.\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lookUp(tagName)"),": Retrieve a tag object by name. Returns the tag object, including its options,\nor ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," if the tag is not defined."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isNamespace(tagName)"),": Returns ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if the tag is applied to a doclet's longname as a\nnamespace."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"normalise(tagName)"),": Returns the canonical name of a tag. For example, the ",(0,i.kt)("inlineCode",{parentName:"li"},"@const")," tag is a\nsynonym for ",(0,i.kt)("inlineCode",{parentName:"li"},"@constant"),"; as a result, if you call ",(0,i.kt)("inlineCode",{parentName:"li"},"normalise('const')"),", it returns the string\n",(0,i.kt)("inlineCode",{parentName:"li"},"constant"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"normalize(tagName)"),": Synonym for ",(0,i.kt)("inlineCode",{parentName:"li"},"normalise"),". Available in JSDoc 3.3.0 and later.")),(0,i.kt)("p",null,"A tag's ",(0,i.kt)("inlineCode",{parentName:"p"},"onTagged")," callback can modify the contents of the doclet or tag."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Defining an onTagged callback"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"dictionary.defineTag('instance', {\n    onTagged: function(doclet, tag) {\n        doclet.scope = \"instance\";\n    }\n});\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"defineTag")," method returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tag")," object, which has a ",(0,i.kt)("inlineCode",{parentName:"p"},"synonym")," method that can be used to\ndeclare a synonym for the tag."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Defining a tag synonym"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"dictionary.defineTag('exception', { /* options for exception tag */ })\n    .synonym('throws');\n")),(0,i.kt)("h3",{id:"node-visitors"},"Node Visitors"),(0,i.kt)("p",null,"At the lowest level, plugin authors can process each node in the abstract syntax tree (AST) by\ndefining a node visitor that will visit each node. By using a node-visitor plugin, you can modify\ncomments and trigger parser events for any arbitrary piece of code."),(0,i.kt)("p",null,"Plugins can define a node visitor by exporting an ",(0,i.kt)("inlineCode",{parentName:"p"},"astNodeVisitor")," object that contains a\n",(0,i.kt)("inlineCode",{parentName:"p"},"visitNode")," function, like so:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"exports.astNodeVisitor = {\n    visitNode: function(node, e, parser, currentSourceName) {\n        // do all sorts of crazy things here\n    }\n};\n")),(0,i.kt)("p",null,"The function is called on each node with the following parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node"),": The AST node. AST nodes are JavaScript objects that use the format defined by the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/estree/estree"},"ESTree\nspec"),". You can use ",(0,i.kt)("a",{parentName:"li",href:"https://astexplorer.net/"},"AST Explorer")," to see the AST that will be created for your\nsource code. As of version 3.5.0, JSDoc uses the current version of the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/babel/babylon"},"Babylon")," parser\nwith all plugins enabled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"e"),": The event. If the node is one that the parser handles, the event object will already be\npopulated with the same things described in the ",(0,i.kt)("inlineCode",{parentName:"li"},"symbolFound")," event above. Otherwise, it will be an\nempty object on which to set various properties."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parser"),": The JSDoc parser instance."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"currentSourceName"),": The name of the file being parsed.")),(0,i.kt)("h4",{id:"making-things-happen"},"Making things happen"),(0,i.kt)("p",null,"The primary reasons to implement a node visitor are to be able to document things that aren't\nnormally documented (like function calls that create classes) or to auto generate documentation for\ncode that isn't documented. For instance, a plugin might look for calls to a ",(0,i.kt)("inlineCode",{parentName:"p"},"_trigger")," method since\nit knows that means an event is fired and then generate documentation for the event."),(0,i.kt)("p",null,"To make things happen, the ",(0,i.kt)("inlineCode",{parentName:"p"},"visitNode")," function should modify properties of the event parameter. In\ngeneral the goal is to construct a comment and then get an event to fire. After the parser lets all\nof the node visitors have a look at the node, it looks to see if the event object has a ",(0,i.kt)("inlineCode",{parentName:"p"},"comment"),"\nproperty and an ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," property. If it has both, the event named in the event property is fired.\nThe event is usually ",(0,i.kt)("inlineCode",{parentName:"p"},"symbolFound")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"jsdocCommentFound"),", but theoretically, a plugin could define\nits own events and handle them."),(0,i.kt)("p",null,"As with event-handler plugins, a node-visitor plugin can stop later plugins from running by setting\na ",(0,i.kt)("inlineCode",{parentName:"p"},"stopPropagation")," property on the event object (",(0,i.kt)("inlineCode",{parentName:"p"},"e.stopPropagation = true"),"). A plugin can stop the\nevent from firing by setting a ",(0,i.kt)("inlineCode",{parentName:"p"},"preventDefault")," property (",(0,i.kt)("inlineCode",{parentName:"p"},"e.preventDefault = true"),")."),(0,i.kt)("h2",{id:"reporting-errors"},"Reporting Errors"),(0,i.kt)("p",null,"If your plugin needs to report an error, use one of the following methods in the ",(0,i.kt)("inlineCode",{parentName:"p"},"jsdoc/util/logger"),"\nmodule:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logger.warn"),": Warn the user about a possible problem."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logger.error"),": Report an error from which the plugin can recover."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logger.fatal"),": Report an error that should cause JSDoc to stop running.")),(0,i.kt)("p",null,"Using these methods creates a better user experience than simply throwing an error."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": Do not use the ",(0,i.kt)("inlineCode",{parentName:"p"},"jsdoc/util/error")," module to report errors. This module is deprecated and\nwill be removed in a future version of JSDoc."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Reporting a non-fatal error"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"var logger = require('jsdoc/util/logger');\n\nexports.handlers = {\n    newDoclet: function(e) {\n        // Your code here.\n\n        if (somethingBadHappened) {\n            logger.error('Oh, no, something bad happened!');\n        }\n    }\n};\n")))}c.isMDXComponent=!0}}]);